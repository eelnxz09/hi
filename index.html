<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SELF‚Ä¢SURFER</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-black text-white overflow-hidden font-mono">
    <div class="flex flex-col h-screen">
        <!-- Top HUD -->
        <header class="h-12 bg-zinc-900 flex items-center px-4 justify-between text-xs uppercase tracking-[0.065em]">
            <div class="flex items-center gap-x-2">
                <span class="inline-block w-px h-3 bg-lime-400"></span>SELF‚Ä¢SURFER
            </div>
            <div id="topScore" class="text-lime-400 font-semibold text-sm">0000000m</div>
        </header>
        
        <!-- Main Game Container -->
        <div class="flex-1 relative flex items-center justify-center bg-zinc-950" id="gameWrapper">
            
            <!-- Start Screen -->
            <div id="startScreen" class="absolute inset-0 z-30 flex flex-col items-center justify-center bg-black/90 transition-opacity">
                <div class="text-center mb-8">
                    <div class="inline-flex items-center gap-2 text-[11px] tracking-[0.065em] text-lime-400 mb-1">
                        POWERED BY YOUR BODY
                    </div>
                    <h1 class="text-[7rem] leading-[0.75] font-black tracking-[-0.02em] mb-1 text-transparent bg-clip-text bg-gradient-to-b from-white via-lime-300 to-lime-400">SELF<br>SURFER</h1>
                    <p class="text-xs uppercase text-zinc-400">Be the legend.<br><span class="text-lime-400">Move. Run. Survive.</span></p>
                </div>
                
                <button onclick="startAvatarCreation()" 
                    id="startButton"
                    class="bg-lime-400 hover:bg-lime-300 transition-colors text-black font-bold px-10 py-4 rounded-xl text-sm uppercase tracking-widest flex items-center gap-3 shadow-[0_0_15px_-2px] shadow-lime-400">
                    <span>TAKE SELFIE ‚Ä¢ START RUN</span>
                    <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7-7 7M5 12h14" />
                    </svg>
                </button>
                
                <div class="mt-12 text-[10px] text-zinc-500">Swipe ‚Ä¢ Lean ‚Ä¢ Jump ‚Ä¢ Slide<br><span class="text-lime-400">using your camera</span></div>
            </div>
            
            <!-- Avatar Creation Modal -->
            <div id="avatarModal" class="hidden absolute inset-0 z-40 flex items-center justify-center bg-black/80">
                <div onclick="event.stopImmediatePropagation()" 
                     id="avatarContent"
                     class="bg-zinc-900 rounded-3xl w-full max-w-[380px] mx-4 overflow-hidden">
                    
                    <!-- Step 1: Capture -->
                    <div id="avatarStep1" class="p-6">
                        <div class="flex justify-between items-center mb-4">
                            <span class="text-xs uppercase tracking-[0.065em] text-lime-400">STEP 01 / 02</span>
                            <button onclick="closeAvatarModal()" id="skipAvatarBtn"
                                class="text-xs text-zinc-400 hover:text-white">Skip for demo ‚Üí</button>
                        </div>
                        
                        <h2 class="font-black text-3xl leading-none mb-1">Capture<br>your vibe</h2>
                        <p class="text-xs text-zinc-400">We‚Äôll turn you into a Self-Surfer legend.</p>
                        
                        <!-- Simulated camera -->
                        <div class="relative mt-6 mb-6 bg-black aspect-[4/3] rounded-2xl overflow-hidden border border-zinc-700">
                            <!-- Fake camera feed -->
                            <div id="cameraFeed" 
                                 class="w-full h-full bg-[url('https://picsum.photos/id/64/800/600')] bg-cover bg-center flex items-center justify-center">
                                <div class="bg-black/60 text-[10px] text-lime-400 px-4 py-1 rounded-full backdrop-blur-sm">LIVE ‚Ä¢ FRONT CAMERA</div>
                            </div>
                            
                            <!-- Pose detection overlay dots -->
                            <div class="absolute inset-0 pointer-events-none">
                                <!-- Fake pose skeleton -->
                                <svg id="fakeSkeleton" width="100%" height="100%" class="absolute inset-0">
                                    <!-- populated by JS -->
                                </svg>
                            </div>
                        </div>
                        
                        <button onclick="simulateSelfieCapture()" 
                            id="captureBtn"
                            class="w-full bg-lime-400 text-black py-4 rounded-2xl font-semibold flex items-center justify-center gap-2 hover:scale-105 transition-transform">
                            üì∏ CAPTURE SELFIE
                        </button>
                        
                        <div class="text-[10px] text-center text-zinc-500 mt-4">or use demo avatar</div>
                    </div>
                    
                    <!-- Step 2: Customize -->
                    <div id="avatarStep2" class="hidden p-6">
                        <div class="flex justify-between items-center mb-4">
                            <span class="text-xs uppercase tracking-[0.065em] text-lime-400">STEP 02 / 02</span>
                            <button onclick="closeAvatarModal()" class="text-xs text-lime-400">Done ‚Üí</button>
                        </div>
                        
                        <div class="flex gap-3 mb-6">
                            <!-- Gender toggle -->
                            <button onclick="toggleGender(0)" id="genderMaleBtn"
                                class="flex-1 py-2 text-xs font-semibold border border-lime-400 bg-lime-400 text-black rounded-xl">MALE</button>
                            <button onclick="toggleGender(1)" id="genderFemaleBtn"
                                class="flex-1 py-2 text-xs font-semibold border border-zinc-700 hover:border-zinc-400 rounded-xl">FEMALE</button>
                        </div>
                        
                        <!-- Avatar preview -->
                        <div class="bg-zinc-950 h-52 rounded-2xl flex items-center justify-center mb-6 relative overflow-hidden" id="avatarPreviewContainer">
                            <!-- Canvas will go here -->
                            <canvas id="avatarPreviewCanvas" width="140" height="140" 
                                class="drop-shadow-xl"></canvas>
                        </div>
                        
                        <!-- Outfit selector -->
                        <div class="mb-5">
                            <p class="text-[11px] uppercase text-zinc-400 tracking-widest mb-2">Streetwear drip</p>
                            <div class="grid grid-cols-4 gap-2" id="outfitSelector">
                                <!-- JS populated -->
                            </div>
                        </div>
                        
                        <button onclick="finishAvatarCreation()" 
                            class="w-full bg-lime-400 hover:bg-emerald-400 transition-all py-4 rounded-2xl text-black font-bold text-sm tracking-[0.065em]">
                            LOCK IN AVATAR ‚Ä¢ ENTER SUBWAY
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Game Screen -->
            <div id="gameScreen" class="hidden relative w-full max-w-[380px] mx-auto h-full flex flex-col">
                <!-- Canvas wrapper -->
                <div class="relative flex-1 flex items-center justify-center bg-[#0a0f17]" style="height: 560px;">
                    <!-- Three-lane canvas -->
                    <canvas 
                        id="gameCanvas" 
                        width="380" 
                        height="560"
                        class="shadow-xl touch-none">
                    </canvas>
                    
                    <!-- Pose overlay -->
                    <div id="poseOverlay" 
                         class="absolute bottom-6 left-1/2 -translate-x-1/2 bg-zinc-900/90 backdrop-blur-md rounded-3xl px-5 py-2 flex items-center gap-5 shadow-inner z-10">
                        
                        <!-- Fake camera indicator -->
                        <div class="flex items-center gap-1.5 text-[10px] text-lime-400 whitespace-nowrap">
                            <span class="inline-block h-px w-3 bg-lime-400"></span> 
                            CAMERA LIVE
                        </div>
                        
                        <!-- Pose buttons -->
                        <div class="flex gap-2">
                            <!-- Lean left -->
                            <button onclick="triggerPoseAction('left')" 
                                id="btnLeft"
                                class="w-7 h-7 bg-zinc-700 hover:bg-lime-400 hover:text-black transition-all rounded-lg flex items-center justify-center text-xs">‚Üê</button>
                            
                            <!-- Jump -->
                            <button onclick="triggerPoseAction('jump')" 
                                id="btnJump"
                                class="px-3 py-px bg-lime-400 text-black text-[13px] font-bold rounded-xl transition-all active:scale-90">JUMP</button>
                            
                            <!-- Slide -->
                            <button onclick="triggerPoseAction('slide')" 
                                id="btnSlide"
                                class="px-3 py-px bg-zinc-700 hover:bg-orange-400 hover:text-black transition-all rounded-xl text-xs">SLIDE</button>
                            
                            <!-- Lean right -->
                            <button onclick="triggerPoseAction('right')" 
                                id="btnRight"
                                class="w-7 h-7 bg-zinc-700 hover:bg-lime-400 hover:text-black transition-all rounded-lg flex items-center justify-center text-xs">‚Üí</button>
                        </div>
                    </div>
                    
                    <!-- "Pose detected" flash indicator -->
                    <div id="poseFlash" 
                         class="hidden absolute inset-0 bg-lime-400 pointer-events-none z-20 mix-blend-screen opacity-0"></div>
                </div>
                
                <!-- In-game HUD -->
                <div class="h-14 bg-zinc-900 flex items-center px-5 text-xs uppercase">
                    <!-- Coins -->
                    <div class="flex items-center gap-2 flex-1">
                        <span class="inline-block text-amber-400">ü™ô</span><span id="coinCount" class="font-mono font-semibold">√ó 00</span>
                    </div>
                    
                    <!-- Distance -->
                    <div class="font-mono text-xs text-center text-zinc-400" id="distanceLabel">284<span class="text-[10px]">m</span></div>
                    
                    <!-- Multiplier -->
                    <div class="flex-1 text-right">
                        <span class="bg-zinc-700 text-[10px] px-2 py-px rounded">√ó<span id="multiplier">1.8</span></span>
                    </div>
                </div>
            </div>
            
            <!-- Game Over Screen -->
            <div id="gameOverScreen" class="hidden absolute inset-0 z-30 bg-black/90 flex flex-col items-center justify-center">
                <div class="text-center">
                    <div class="mb-1 text-lime-400 text-xs tracking-[0.065em] font-semibold">RUN ENDED ‚Ä¢ 284m</div>
                    <h2 id="finalDistance" class="font-black text-[6.5rem] leading-none tracking-tighter mb-1">284<span class="text-base align-super">m</span></h2>
                    
                    <div class="flex justify-center gap-7 mb-7 text-xs">
                        <div>
                            <div class="text-zinc-400">COINS</div>
                            <div id="finalCoins" class="font-mono text-amber-400 text-lg">28</div>
                        </div>
                        <div>
                            <div class="text-zinc-400">HIGH SCORE</div>
                            <div id="highScoreDisplay" class="font-mono text-lime-400 text-lg">1284</div>
                        </div>
                    </div>
                    
                    <button onclick="restartGame()" 
                        class="bg-lime-400 hover:bg-lime-300 px-14 py-3 rounded-2xl text-black font-bold text-sm block mx-auto mb-4 transition-colors">
                        RUN AGAIN
                    </button>
                    
                    <button onclick="returnToStart()" 
                        class="text-xs text-zinc-400 underline">Change avatar / Try new drip</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Tailwind script already injected via CDN
        
        // Game constants
        const CANVAS_WIDTH = 380;
        const CANVAS_HEIGHT = 560;
        
        // Game variables
        let canvas, ctx;
        let gameState = "start"; // start, playing, gameover
        let player = {
            lane: 1, // 0 left, 1 center, 2 right
            targetLane: 1,
            x: CANVAS_WIDTH / 2,
            y: 410,
            width: 32,
            height: 54,
            velocityY: 0,
            isJumping: false,
            isSliding: false,
            slideTimer: 0
        };
        
        let obstacles = [];
        let coins = [];
        let particles = [];
        let score = 0;
        let distance = 0;
        let coinCount = 0;
        let speed = 3.2;
        let frame = 0;
        let highScore = localStorage.getItem("selfSurferHighScore") ? parseInt(localStorage.getItem("selfSurferHighScore")) : 872;
        
        let keys = {};
        let lastSwipeTime = 0;
        
        let avatarData = {
            gender: 0, // 0 male, 1 female
            outfitIndex: 2,
            name: "Alex"
        };
        
        const lanePositions = [92, 190, 288]; // X positions for 3 lanes
        
        // Fake outfit names
        const outfits = ["Neon Hood", "Ripped Tech", "Cyber Drip", "Skate Punk", "Chrome Kicks"];
        
        // Audio context for sounds
        let audioCtx;
        
        // Game loop variables
        let animationFrameId;
        
        // Fake MediaPipe simulation
        let currentPose = null;
        
        class Obstacle {
            constructor(lane, type) {
                this.lane = lane;
                this.type = type; // "train", "barrier", "ramp"
                this.z = 560; // distance from player, higher = farther away
                this.heightOffset = type === "train" ? 22 : 0;
            }
            
            update() {
                this.z -= speed;
            }
            
            isOffscreen() {
                return this.z < 80;
            }
            
            getScreenY() {
                // Perspective mapping
                return 210 + (560 - this.z) * 0.62;
            }
            
            getScale() {
                return Math.min(1, (560 - this.z) / 260);
            }
        }
        
        class Coin {
            constructor(lane) {
                this.lane = lane;
                this.z = 560;
                this.collected = false;
                this.rotation = 0;
            }
            
            update() {
                this.z -= speed;
                this.rotation += 0.1;
            }
            
            isOffscreen() {
                return this.z < 70;
            }
            
            getScreenY() {
                return 200 + (560 - this.z) * 0.62;
            }
        }
        
        // Fake pose detection trigger
        function triggerPoseAction(action) {
            if (gameState !== "playing") return;
            
            document.getElementById("poseFlash").classList.remove("hidden");
            setTimeout(() => {
                document.getElementById("poseFlash").classList.add("hidden");
            }, 60);
            
            switch(action) {
                case "left":
                    changeLane(-1);
                    flashPoseButton("btnLeft");
                    break;
                case "right":
                    changeLane(1);
                    flashPoseButton("btnRight");
                    break;
                case "jump":
                    if (!player.isJumping && !player.isSliding) {
                        player.velocityY = -14;
                        player.isJumping = true;
                        playSound("jump", 520);
                        flashPoseButton("btnJump");
                    }
                    break;
                case "slide":
                    if (!player.isJumping && !player.isSliding) {
                        player.isSliding = true;
                        player.slideTimer = 22;
                        playSound("slide", 180);
                        flashPoseButton("btnSlide");
                    }
                    break;
            }
            
            // Fake "AI confidence"
            document.getElementById("poseOverlay").style.borderColor = "#a3e635";
            setTimeout(() => {
                document.getElementById("poseOverlay").style.borderColor = "#272727";
            }, 180);
        }
        
        function flashPoseButton(btnId) {
            const btn = document.getElementById(btnId);
            const originalColor = btn.style.backgroundColor;
            btn.style.backgroundColor = "#bef575";
            btn.style.color = "#09090b";
            setTimeout(() => {
                btn.style.backgroundColor = originalColor || "";
                btn.style.color = "";
            }, 90);
        }
        
        function changeLane(dir) {
            let newLane = player.targetLane + dir;
            if (newLane < 0 || newLane > 2) return;
            player.targetLane = newLane;
            
            playSound("laneChange", 680);
        }
        
        function initCanvas() {
            canvas = document.getElementById("gameCanvas");
            ctx = canvas.getContext("2d", { alpha: true });
        }
        
        function drawBackground() {
            // Sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, 310);
            skyGradient.addColorStop(0, "#0b1625");
            skyGradient.addColorStop(1, "#1f2a43");
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, 310);
            
            // Neon city skyline silhouette
            ctx.fillStyle = "#111d33";
            ctx.fillRect(0, 210, CANVAS_WIDTH, 120);
            
            // Buildings
            ctx.fillStyle = "#16233f";
            // Building 1
            ctx.fillRect(12, 125, 42, 105);
            ctx.fillRect(72, 98, 34, 132);
            ctx.fillRect(138, 148, 51, 82);
            ctx.fillRect(215, 110, 29, 120);
            ctx.fillRect(270, 135, 44, 95);
            
            // Neon windows
            ctx.fillStyle = "#bef574";
            ctx.fillRect(25, 155, 6, 6);
            ctx.fillRect(32, 172, 6, 6);
            ctx.fillRect(85, 125, 7, 7);
            ctx.fillRect(155, 190, 6, 6);
            ctx.fillRect(230, 142, 6, 6);
            
            // Ground area
            ctx.fillStyle = "#121212";
            ctx.fillRect(0, 310, CANVAS_WIDTH, CANVAS_HEIGHT - 310);
            
            // Perspective rails / floor lines
            ctx.strokeStyle = "#272727";
            ctx.lineWidth = 6;
            
            // 3 lanes floor
            const horizonY = 310;
            for (let i = -1; i <= 4; i++) {
                const y = horizonY + i * 48;
                const widthAtY = 280 + (y - horizonY) * 0.6;
                
                ctx.beginPath();
                ctx.moveTo((CANVAS_WIDTH - widthAtY)/2, y);
                ctx.lineTo((CANVAS_WIDTH + widthAtY)/2, y);
                ctx.stroke();
            }
            
            // Lane dividers (converging)
            ctx.strokeStyle = "#4ade80";
            ctx.lineWidth = 3;
            
            // Left divider
            ctx.shadowColor = "#84cc16";
            ctx.shadowBlur = 14;
            ctx.beginPath();
            ctx.moveTo(140, horizonY);
            ctx.lineTo(70, CANVAS_HEIGHT);
            ctx.stroke();
            
            // Center divider
            ctx.beginPath();
            ctx.moveTo(CANVAS_WIDTH/2, horizonY);
            ctx.lineTo(CANVAS_WIDTH/2, CANVAS_HEIGHT);
            ctx.stroke();
            
            // Right divider
            ctx.beginPath();
            ctx.moveTo(240, horizonY);
            ctx.lineTo(310, CANVAS_HEIGHT);
            ctx.stroke();
            
            ctx.shadowBlur = 0;
        }
        
        function drawPlayer() {
            const laneX = lanePositions[player.lane];
            let renderX = player.x;
            
            // Smooth lane transition
            if (player.x !== laneX) {
                player.x += (laneX - player.x) * 0.28;
            }
            
            const bob = Math.sin(frame / 5) * 2;
            
            let py = player.y + bob;
            
            // Sliding posture
            let legOffset = 0;
            let torsoHeight = player.height;
            
            if (player.isSliding) {
                py += 22;
                torsoHeight = 24;
                legOffset = 12;
            }
            
            // Shadow
            ctx.shadowColor = "rgba(0,0,0,.7)";
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 14;
            ctx.fillStyle = "rgba(16,30,22,.6)";
            ctx.beginPath();
            ctx.ellipse(player.x + 2, player.y + 48, 17, 7, 0, 0, Math.PI*2);
            ctx.fill();
            
            ctx.shadowOffsetY = 0;
            ctx.shadowBlur = 0;
            
            // Legs
            ctx.strokeStyle = avatarData.gender === 0 ? "#eab308" : "#ec4899";
            ctx.lineWidth = 7;
            
            // Left leg
            ctx.beginPath();
            ctx.moveTo(player.x - 7, py + 33);
            ctx.lineTo(player.x - 7, py + 48 + legOffset);
            ctx.stroke();
            
            // Right leg
            ctx.beginPath();
            ctx.moveTo(player.x + 7, py + 33);
            ctx.lineTo(player.x + 9, py + 48 + legOffset);
            ctx.stroke();
            
            // Torso
            ctx.fillStyle = "#111";
            ctx.fillRect(player.x - 13, py + 6, 26, torsoHeight);
            
            // Jacket / outfit highlight
            ctx.fillStyle = avatarData.gender === 0 ? "#eab308" : "#c026d3";
            ctx.fillRect(player.x - 13, py + 11, 26, 14);
            
            // Head
            ctx.fillStyle = "#f5e8c7";
            ctx.beginPath();
            ctx.arc(player.x, py + 7, 9, 0, Math.PI*2);
            ctx.fill();
            
            // Hair / cap
            if (avatarData.gender === 0) {
                ctx.fillStyle = "#111";
                ctx.fillRect(player.x - 9, py - 2, 18, 7); // cap
            } else {
                ctx.fillStyle = "#ec4899";
                ctx.beginPath();
                ctx.ellipse(player.x, py + 1, 11, 7, 0, 0, Math.PI*2);
                ctx.fill();
            }
            
            // Neon visor / goggles
            ctx.fillStyle = "#67e8f9";
            ctx.fillRect(player.x - 6, py + 5, 12, 3);
            
            // Arms
            ctx.strokeStyle = "#111";
            ctx.lineWidth = 6;
            
            // Left arm
            ctx.beginPath();
            ctx.moveTo(player.x - 11, py + 17);
            ctx.lineTo(player.x - 18, py + (player.isSliding ? 26 : 30));
            ctx.stroke();
            
            // Right arm
            ctx.beginPath();
            ctx.moveTo(player.x + 11, py + 17);
            ctx.lineTo(player.x + 16, py + (player.isSliding ? 25 : 32));
            ctx.stroke();
            
            // Jump animation stretch
            if (player.isJumping) {
                ctx.save();
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = "#bef574";
                ctx.fillRect(player.x - 17, py + 24, 34, 5);
                ctx.restore();
            }
        }
        
        function drawObstacles() {
            for (let obstacle of obstacles) {
                const scale = obstacle.getScale();
                const screenY = obstacle.getScreenY();
                const laneX = lanePositions[obstacle.lane];
                
                const w = 42 * scale;
                const h = 44 * scale;
                
                // Train glow when far away
                if (obstacle.type === "train") {
                    ctx.shadowColor = "#eab308";
                    ctx.shadowBlur = 22 * scale;
                    
                    ctx.fillStyle = "#272727";
                    // Train body
                    ctx.fillRect(laneX - w/2, screenY - h + obstacle.heightOffset, w, h);
                    
                    // Train "windows"
                    ctx.fillStyle = "#eab308";
                    ctx.fillRect(laneX - w/2 + 5, screenY - h + 11 + obstacle.heightOffset, w - 13, 7);
                    
                    ctx.shadowBlur = 0;
                } 
                else if (obstacle.type === "barrier") {
                    // Concrete barrier
                    ctx.fillStyle = "#444";
                    ctx.fillRect(laneX - w/2 + 3, screenY - 12, w - 6, 16);
                    
                    ctx.fillStyle = "#eab308";
                    ctx.fillRect(laneX - w/2 + 6, screenY - 18, w - 14, 5); // top stripe
                }
                else if (obstacle.type === "ramp") {
                    // Ramp
                    ctx.fillStyle = "#334455";
                    ctx.beginPath();
                    ctx.moveTo(laneX - w/2, screenY);
                    ctx.lineTo(laneX + w/2, screenY);
                    ctx.lineTo(laneX + w/3, screenY - 32 * scale);
                    ctx.fill();
                    
                    ctx.strokeStyle = "#a3e635";
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(laneX - w/2 + 6, screenY - 4);
                    ctx.lineTo(laneX + w/2 - 6, screenY - 4);
                    ctx.stroke();
                }
            }
        }
        
        function drawCoins() {
            for (let coin of coins) {
                if (coin.collected) continue;
                
                const scale = Math.min(1.1, (560 - coin.z) / 230);
                const screenY = coin.getScreenY();
                const laneX = lanePositions[coin.lane];
                
                const radius = 13 * scale;
                
                // Coin shadow
                ctx.shadowColor = "#000";
                ctx.shadowBlur = 3;
                ctx.shadowOffsetY = 6;
                ctx.beginPath();
                ctx.ellipse(laneX, screenY + 6, radius * 0.9, radius * 0.3, 0, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(0,0,0,.45)";
                ctx.fill();
                
                // Coin itself
                ctx.shadowColor = "#fde047";
                ctx.shadowBlur = 15;
                ctx.fillStyle = "#fde047";
                ctx.beginPath();
                ctx.arc(laneX, screenY, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner ring
                ctx.strokeStyle = "#ca8a04";
                ctx.lineWidth = 3.5 * scale;
                ctx.beginPath();
                ctx.arc(laneX, screenY, radius - 4, 0, Math.PI * 2);
                ctx.stroke();
                
                // Highlight shine
                ctx.fillStyle = "rgba(255,255,255,.85)";
                ctx.beginPath();
                ctx.arc(laneX - 3, screenY - 4, 4 * scale, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life--;
                p.y += p.vy;
                p.x += p.vx;
                
                ctx.globalAlpha = p.life / 22;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, 4, 4);
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            ctx.globalAlpha = 1;
        }
        
        function generateObstacle() {
            if (Math.random() < 0.032 + speed / 75) {
                const lane = Math.floor(Math.random() * 3);
                
                // Avoid stacking on same lane too much
                let type;
                const rand = Math.random();
                
                if (rand < 0.32) {
                    type = "train";
                } else if (rand < 0.65) {
                    type = "barrier";
                } else {
                    type = "ramp";
                }
                
                // Avoid placing obstacles too close to each other
                let tooClose = false;
                for (let obs of obstacles) {
                    if (obs.lane === lane && obs.z > 320) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    obstacles.push(new Obstacle(lane, type));
                }
            }
        }
        
        function generateCoin() {
            // Occasionally spawn a coin
            if (Math.random() < 0.055) {
                const lane = Math.floor(Math.random() * 3);
                
                // Avoid spawning directly on an obstacle if possible
                let canSpawn = true;
                for (let obs of obstacles) {
                    if (obs.lane === lane && obs.z > 400 && obs.z < 480) {
                        canSpawn = false;
                    }
                }
                if (canSpawn) {
                    coins.push(new Coin(lane));
                }
            }
        }
        
        function checkCollisions() {
            const px = player.x;
            const py = player.y;
            
            // Obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                
                if (obs.z < 150 && obs.z > 75) {
                    const obsX = lanePositions[obs.lane];
                    
                    // Check lane match
                    if (player.lane === obs.lane) {
                        // Check if ducking under train
                        if (obs.type === "train") {
                            if (!player.isSliding) {
                                triggerGameOver();
                                return;
                            }
                        }
                        // Check if jumping over barrier
                        else if (obs.type === "barrier" || obs.type === "ramp") {
                            if (!player.isJumping) {
                                triggerGameOver();
                                return;
                            }
                        }
                    }
                }
            }
            
            // Coins
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                if (coin.collected) continue;
                
                if (coin.z < 155 && coin.z > 90) {
                    const coinX = lanePositions[coin.lane];
                    
                    const dist = Math.abs(coinX - px);
                    
                    if (dist < 34 && !player.isSliding) { // can collect even when jumping
                        coin.collected = true;
                        coinCount++;
                        document.getElementById("coinCount").innerText = "√ó " + String(coinCount).padStart(2, '0');
                        
                        // Particle explosion
                        for (let k = 0; k < 13; k++) {
                            const angle = Math.random() * Math.PI * 2;
                            particles.push({
                                x: coinX,
                                y: coin.getScreenY() - 6,
                                vx: Math.cos(angle) * 3.5,
                                vy: Math.sin(angle) * 2.5 - 2,
                                life: 21,
                                color: "#fde047"
                            });
                        }
                        
                        playSound("coin", 1100);
                        
                        // Increase multiplier occasionally
                        if (coinCount % 7 === 0) {
                            speed = Math.min(6.8, speed + 0.2);
                        }
                    }
                }
            }
        }
        
        function update() {
            if (gameState !== "playing") return;
            
            frame++;
            distance += 0.26;
            
            document.getElementById("distanceLabel").innerText = Math.floor(distance);
            document.getElementById("topScore").innerText = Math.floor(distance).toString().padStart(7, "0") + "m";
            
            // Update player jump
            if (player.isJumping) {
                player.velocityY += 0.72;
                player.y += player.velocityY;
                
                if (player.y >= 410) {
                    player.y = 410;
                    player.velocityY = 0;
                    player.isJumping = false;
                }
            }
            
            // Slide timer
            if (player.isSliding) {
                player.slideTimer--;
                if (player.slideTimer <= 0) {
                    player.isSliding = false;
                }
            }
            
            // Update lane
            if (Math.abs(player.x - lanePositions[player.targetLane]) < 4) {
                player.lane = player.targetLane;
            }
            
            // Update obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].update();
                if (obstacles[i].isOffscreen()) {
                    obstacles.splice(i, 1);
                }
            }
            
            // Update coins
            for (let i = coins.length - 1; i >= 0; i--) {
                coins[i].update();
                if (coins[i].isOffscreen()) {
                    coins.splice(i, 1);
                }
            }
            
            // Generate new obstacles & coins
            generateObstacle();
            generateCoin();
            
            // Increase difficulty
            if (frame % 38 === 0 && speed < 6.8) {
                speed += 0.035;
            }
            
            checkCollisions();
            
            // Fake random pose detection demo (once in a while)
            if (frame % 71 === 0 && Math.random() > 0.6 && !player.isJumping && !player.isSliding) {
                const r = Math.random();
                if (r < 0.4) {
                    // random jump
                    player.velocityY = -14;
                    player.isJumping = true;
                    playSound("jump", 520);
                } 
                else if (r < 0.7) {
                    // random slide
                    player.isSliding = true;
                    player.slideTimer = 19;
                    playSound("slide", 180);
                }
            }
        }
        
        function render() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            drawBackground();
            
            // Draw far objects first
            drawObstacles();
            drawCoins();
            
            drawPlayer();
            
            drawParticles();
            
            // Track lines glow effect
            ctx.save();
            ctx.globalAlpha = 0.35 + Math.sin(frame/7) * 0.1;
            ctx.strokeStyle = "#bef574";
            ctx.lineWidth = 22;
            ctx.shadowColor = "#bef574";
            ctx.shadowBlur = 30;
            
            ctx.beginPath();
            ctx.moveTo(85, 315);
            ctx.lineTo(85, CANVAS_HEIGHT);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(295, 315);
            ctx.lineTo(295, CANVAS_HEIGHT);
            ctx.stroke();
            ctx.restore();
        }
        
        function gameLoop() {
            update();
            render();
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        function triggerGameOver() {
            gameState = "gameover";
            
            // Hit animation
            playSound("hit", 140);
            
            // Explosion particles
            for (let i = 0; i < 32; i++) {
                const angle = Math.random() * Math.PI * 2;
                particles.push({
                    x: player.x + Math.random()*12-6,
                    y: player.y + 12,
                    vx: Math.cos(angle) * (2 + Math.random()*6),
                    vy: Math.sin(angle) * (Math.random()*3 - 5),
                    life: 30 + Math.random() * 14,
                    color: (Math.random() > .5) ? "#eab308" : "#ef4444"
                });
            }
            
            document.getElementById("gameOverScreen").classList.remove("hidden");
            
            document.getElementById("finalDistance").innerHTML = 
                Math.floor(distance) + `<span class="text-base align-super text-zinc-400">m</span>`;
            
            document.getElementById("finalCoins").innerText = coinCount;
            
            if (distance > highScore) {
                highScore = Math.floor(distance);
                localStorage.setItem("selfSurferHighScore", highScore);
            }
            
            document.getElementById("highScoreDisplay").innerText = highScore;
        }
        
        function playSound(type, freq) {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            switch(type) {
                case "coin":
                    oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
                    oscillator.type = "sine";
                    gainNode.gain.value = 0.25;
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.09);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.11);
                    break;
                case "jump":
                    oscillator.frequency.setValueAtTime(320, audioCtx.currentTime);
                    gainNode.gain.value = 0.3;
                    oscillator.type = "triangle";
                    oscillator.start();
                    oscillator.frequency.exponentialRampToValueAtTime(720, audioCtx.currentTime + 0.22);
                    gainNode.gain.exponentialRampToValueAtTime(.001, audioCtx.currentTime + 0.28);
                    oscillator.stop(audioCtx.currentTime + 0.28);
                    break;
                case "slide":
                    gainNode.gain.value = 0.15;
                    oscillator.type = "sawtooth";
                    oscillator.frequency.setValueAtTime(80, audioCtx.currentTime);
                    oscillator.start();
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.18);
                    oscillator.stop(audioCtx.currentTime + 0.19);
                    break;
                case "laneChange":
                    gainNode.gain.value = 0.1;
                    oscillator.frequency.setValueAtTime(920, audioCtx.currentTime);
                    oscillator.type = "sine";
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.04);
                    break;
                case "hit":
                    oscillator.type = "sawtooth";
                    oscillator.frequency.setValueAtTime(110, audioCtx.currentTime);
                    gainNode.gain.value = 0.4;
                    oscillator.start();
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.25);
                    oscillator.stop(audioCtx.currentTime + 0.25);
                    break;
            }
        }
        
        // Simulate selfie capture
        function simulateSelfieCapture() {
            const captureBtn = document.getElementById("captureBtn");
            const originalText = captureBtn.textContent;
            
            captureBtn.style.pointerEvents = "none";
            captureBtn.textContent = "‚úì PROCESSING WITH AI...";
            captureBtn.classList.remove("bg-lime-400");
            captureBtn.classList.add("bg-emerald-400");
            
            setTimeout(() => {
                // Fake pose skeleton animation
                animateFakeSkeleton();
                
                setTimeout(() => {
                    captureBtn.textContent = "‚úÖ AVATAR GENERATED";
                    
                    // Switch to step 2
                    document.getElementById("avatarStep1").classList.add("hidden");
                    document.getElementById("avatarStep2").classList.remove("hidden");
                    
                    initAvatarPreviewCanvas();
                    populateOutfitSelector();
                }, 320);
            }, 1050);
        }
        
        function animateFakeSkeleton() {
            const svg = document.getElementById("fakeSkeleton");
            svg.innerHTML = `
                <line x1="110" y1="120" x2="155" y2="210" stroke="#bef574" stroke-width="5" stroke-linecap="round"/>
                <line x1="200" y1="120" x2="155" y2="210" stroke="#bef574" stroke-width="5" stroke-linecap="round"/>
                <line x1="155" y1="210" x2="155" y2="290" stroke="#bef574" stroke-width="5" stroke-linecap="round"/>
                <line x1="155" y1="255" x2="115" y2="305" stroke="#bef574" stroke-width="5" stroke-linecap="round"/>
                <line x1="155" y1="255" x2="195" y2="302" stroke="#bef574" stroke-width="5" stroke-linecap="round"/>
                <circle cx="155" cy="105" r="21" fill="none" stroke="#bef574" stroke-width="11"/>
            `;
            
            // Blink effect
            setTimeout(() => {
                svg.style.opacity = 0.3;
                setTimeout(() => { svg.style.opacity = 1; }, 80);
            }, 210);
        }
        
        function toggleGender(g) {
            avatarData.gender = g;
            
            document.getElementById("genderMaleBtn").classList.toggle("bg-lime-400", g === 0);
            document.getElementById("genderMaleBtn").classList.toggle("text-black", g === 0);
            document.getElementById("genderMaleBtn").classList.toggle("border-lime-400", g === 0);
            
            document.getElementById("genderFemaleBtn").classList.toggle("bg-lime-400", g === 1);
            document.getElementById("genderFemaleBtn").classList.toggle("text-black", g === 1);
            document.getElementById("genderFemaleBtn").classList.toggle("border-lime-400", g === 1);
            
            initAvatarPreviewCanvas();
        }
        
        let avatarPreviewCtx;
        
        function initAvatarPreviewCanvas() {
            const previewCanvas = document.getElementById("avatarPreviewCanvas");
            avatarPreviewCtx = previewCanvas.getContext("2d");
            
            renderAvatarPreview();
        }
        
        function renderAvatarPreview() {
            const ctxP = avatarPreviewCtx;
            ctxP.clearRect(0, 0, 140, 140);
            
            const centerX = 70;
            const baseY = 105;
            
            // Shadow
            ctxP.shadowColor = "#00000030";
            ctxP.shadowOffsetY = 8;
            ctxP.shadowBlur = 5;
            ctxP.fillStyle = "#00000030";
            ctxP.beginPath();
            ctxP.ellipse(centerX, baseY+10, 21, 5, 0, 0, 2*Math.PI);
            ctxP.fill();
            
            // Legs
            ctxP.strokeStyle = avatarData.gender === 0 ? "#ca8a04" : "#db2777";
            ctxP.lineWidth = 11;
            ctxP.lineJoin = "round";
            ctxP.beginPath();
            ctxP.moveTo(centerX-7, baseY);
            ctxP.lineTo(centerX-7, baseY+11);
            ctxP.moveTo(centerX+7, baseY);
            ctxP.lineTo(centerX+7, baseY+11);
            ctxP.stroke();
            
            // Torso
            ctxP.fillStyle = "#111111";
            ctxP.fillRect(centerX-14, baseY-32, 28, 34);
            
            // Jacket stripe
            ctxP.fillStyle = avatarData.gender === 0 ? "#eab308" : "#db2777";
            ctxP.fillRect(centerX-14, baseY-23, 28, 9);
            
            // Head
            ctxP.fillStyle = "#f5e1c0";
            ctxP.beginPath();
            ctxP.arc(centerX, baseY-36, 14, 0, Math.PI*2);
            ctxP.fill();
            
            // Cap / Hair
            if (avatarData.gender === 0) {
                ctxP.fillStyle = "#111";
                ctxP.fillRect(centerX-12, baseY-48, 24, 11);
                // brim
                ctxP.fillStyle = "#eab308";
                ctxP.fillRect(centerX-14, baseY-41, 26, 4);
            } else {
                ctxP.fillStyle = "#db2777";
                ctxP.beginPath();
                ctxP.ellipse(centerX, baseY-42, 14, 9, 0, 0, Math.PI*2);
                ctxP.fill();
            }
            
            // Visor
            ctxP.fillStyle = "#67e8f9";
            ctxP.fillRect(centerX - 7, baseY - 34, 14, 4);
            
            ctxP.shadowBlur = 0;
        }
        
        function populateOutfitSelector() {
            let html = "";
            
            for (let i = 0; i < 5; i++) {
                const active = avatarData.outfitIndex === i ? "border-lime-400 bg-lime-300" : "border-zinc-700";
                html += `
                    <button data-index="${i}" onclick="changeOutfit(this)" 
                        class="outfit-btn h-9 w-full aspect-square border-2 rounded-xl flex-shrink-0 transition-all ${active}">
                        <span class="block text-[9px] text-center leading-none pt-px">${i+1}</span>
                    </button>
                `;
            }
            document.getElementById("outfitSelector").innerHTML = html;
        }
        
        function changeOutfit(el) {
            document.querySelectorAll(".outfit-btn").forEach(btn => {
                btn.classList.toggle("border-lime-400", btn === el);
                btn.classList.toggle("bg-lime-300", btn === el);
            });
            
            avatarData.outfitIndex = parseInt(el.getAttribute("data-index"));
            
            // Slight change to avatar to simulate new outfit
            renderAvatarPreview();
        }
        
        function finishAvatarCreation() {
            document.getElementById("avatarModal").classList.add("hidden");
            
            // Transition into game
            document.getElementById("startScreen").classList.add("hidden");
            document.getElementById("gameScreen").classList.remove("hidden");
            
            // Start the actual game
            resetGame();
            gameState = "playing";
        }
        
        function startAvatarCreation() {
            document.getElementById("avatarModal").classList.remove("hidden");
            document.getElementById("avatarStep1").classList.remove("hidden");
            document.getElementById("avatarStep2").classList.add("hidden");
        }
        
        function closeAvatarModal() {
            // Allow skipping to demo avatar
            document.getElementById("avatarModal").classList.add("hidden");
            
            document.getElementById("startScreen").classList.add("hidden");
            document.getElementById("gameScreen").classList.remove("hidden");
            
            resetGame();
            gameState = "playing";
        }
        
        function resetGame() {
            obstacles = [];
            coins = [];
            particles = [];
            
            player.lane = 1;
            player.targetLane = 1;
            player.x = lanePositions[1];
            player.y = 410;
            player.isJumping = false;
            player.isSliding = false;
            
            distance = 0;
            coinCount = 0;
            speed = 3.2;
            frame = 0;
            
            document.getElementById("coinCount").innerText = "√ó 00";
            document.getElementById("distanceLabel").innerText = "0";
            
            // Seed initial obstacles and coins
            obstacles.push(new Obstacle(0, "barrier"));
            obstacles[0].z = 280;
            
            coins.push(new Coin(2));
            coins[0].z = 370;
        }
        
        function returnToStart() {
            document.getElementById("gameOverScreen").classList.add("hidden");
            document.getElementById("gameScreen").classList.add("hidden");
            document.getElementById("startScreen").classList.remove("hidden");
            
            gameState = "start";
            
            // Stop canvas loop if needed (but we never cancel it)
        }
        
        function restartGame() {
            document.getElementById("gameOverScreen").classList.add("hidden");
            
            resetGame();
            gameState = "playing";
        }
        
        // Keyboard controls for desktop testing
        function setupKeyboard() {
            window.addEventListener("keydown", e => {
                if (gameState !== "playing") return;
                
                switch(e.key) {
                    case "ArrowLeft":
                    case "a":
                    case "A":
                        e.preventDefault();
                        changeLane(-1);
                        break;
                    case "ArrowRight":
                    case "d":
                    case "D":
                        e.preventDefault();
                        changeLane(1);
                        break;
                    case " ":
                    case "Spacebar":
                        e.preventDefault();
                        if (!player.isJumping && !player.isSliding) {
                            player.velocityY = -14;
                            player.isJumping = true;
                            playSound("jump", 520);
                        }
                        break;
                    case "Shift":
                        e.preventDefault();
                        if (!player.isJumping && !player.isSliding) {
                            player.isSliding = true;
                            player.slideTimer = 22;
                            playSound("slide", 180);
                        }
                        break;
                }
            });
        }
        
        // Touch swipe support
        function setupTouchControls() {
            let touchStartX = 0;
            let touchStartY = 0;
            
            const canvasEl = document.getElementById("gameCanvas");
            
            canvasEl.addEventListener("touchstart", function(e) {
                if (gameState !== "playing") return;
                
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, false);
            
            canvasEl.addEventListener("touchend", function(e) {
                if (gameState !== "playing") return;
                
                const touchEndX = e.changedTouches[0].screenX;
                const touchEndY = e.changedTouches[0].screenY;
                
                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;
                
                const now = Date.now();
                
                if (now - lastSwipeTime < 140) return;
                
                // Horizontal swipe for lane change
                if (Math.abs(deltaX) > 55 && Math.abs(deltaX) > Math.abs(deltaY)) {
                    lastSwipeTime = now;
                    if (deltaX > 0) {
                        changeLane(1);
                    } else {
                        changeLane(-1);
                    }
                }
                
                // Vertical swipe up for jump
                else if (deltaY < -55 && Math.abs(deltaY) > Math.abs(deltaX)) {
                    lastSwipeTime = now;
                    if (!player.isJumping && !player.isSliding) {
                        player.velocityY = -14;
                        player.isJumping = true;
                        playSound("jump", 520);
                    }
                }
                
                // Vertical swipe down for slide
                else if (deltaY > 48 && Math.abs(deltaY) > 30) {
                    lastSwipeTime = now;
                    if (!player.isJumping && !player.isSliding) {
                        player.isSliding = true;
                        player.slideTimer = 20;
                        playSound("slide", 180);
                    }
                }
            }, false);
        }
        
        // Modal click away handler
        function setupModals() {
            document.getElementById("avatarModal").addEventListener("click", function(e) {
                if (e.target === this) {
                    // Only allow closing if we already captured (step 2)
                    if (!document.getElementById("avatarStep2").classList.contains("hidden")) {
                        closeAvatarModal();
                    }
                }
            });
        }
        
        // Initialize everything
        window.onload = () => {
            initCanvas();
            
            document.getElementById("highScoreDisplay").innerText = highScore;
            
            setupKeyboard();
            setupTouchControls();
            setupModals();
            
            // Fake "camera" permission already accepted
            console.log("%cüì∏ Self-Surfer running in browser.\nBody tracking simulated using interactive controls.", 
                "color:#84cc16;font-weight:bold");
            
            // Start render loop
            gameLoop();
            
            // Intro demo: spawn some initial coins after load
            setTimeout(() => {
                console.log("%cTap JUMP / swipe up to leap the barriers.\nYour body controls the legend.", 
                    "color:#eab308");
            }, 120);
        }
    </script>
    
</body>
</html>
